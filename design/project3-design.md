تمرین گروهی ۳ - مستند طراحی
======================

گروه: ۶
-----

>>‫نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

پارسا حسینی <sp.hoseiny@gmail.com>

علیرضا دهقانپور فراشاه <alirezafarashah@gmail.com> 

آرمان بابایی <292arma@gmail.com> 

مهدی سلمانی صالح‌آبادی <m10.salmani@gmail.com> 

مقدمات
----------

>>‫ ‫‫اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  ‫بنویسید.

>>‫ لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع‫ ‫درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

بافر کش
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را‫ بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```C
struct chache_block
{
    block_sector_t sector_num;
    bool vaild;
    bool dirty;
    char data[BLOCK_SECTOR_SIZE];
    struct list_elem chache_elem;
    struct lock chache_lock;

    // for second chance algorithm
    bool chance;
}
// for LRU
struct list cache;


// for second chance algorithm
cache_blcok cache[64];

struct lock cache_list_lock;
```


الگوریتم‌ها
------------

>>‫ توضیح دهید که الگوریتم مورد استفاده‌ی شما به چه صورت یک بلاک را برای جایگزین ‫ شدن انتخاب می‌کند؟

برای این کار یک لیست از `cache_block` به اندازه ۶۴ گرفتیم و این لیست ترتیبش نشان دهنده زمان دسترسی به آن
`sector`
است و زمانی که بخواهیم یک 
‍`sector` 
جدید را اضافه کنیم از انتهای لیست حذف میکنیم و آن را به ابتدای لیست اضافه میکنیم.


>>‫ روش پیاده‌سازی `read-ahead` را توضیح دهید.

```C
    block_sector_t sector_idx = byte_to_sector (inode, offset);
```
کافی است وقتی میخواهیم به اندازه 
`size`
در تابع 
`inode_read_at`
بخوانیم اگر محل 
`sector`
مورد نظر در حافظه کش نبود کل آن 
`sector`
را در حافظه کش قرار دهیم.


همگام سازی
-------------

>>‫ هنگامی که یک پردازه به طور مستمر در حال خواندن یا نوشتن داده در یک بلاک بافرکش‫ می‌باشد به چه صورت از دخالت سایر پردازه‌ها جلوگیری میشود؟

برای هر 
`chache_block`
یک 
`lock`
در نظر گرفته ایم که هر پردازه که میخواهد با یک 
`sector`
از حافظه کش کار کند نیاز دارد ابتدا آن `lock` را 
‍‍`acquire`
کند.

>>‫ در حین خارج شدن یک بلوک از حافظه‌ی نهان، چگونه از پروسه‌های دیگر جلوگیری می‌شود تا‫ به این بلاک دسترسی پیدا نکنند؟

با همان 
`lock`
که در سوال قبل توضیح داده شد.
اگر بخواهیم لیست را تغییر دهیم باید از لاکی که برای لیست گرفتیم نیز استفاده کنیم ولی اگر
از همان آرایه و الگوریتم شانس مجدد استفاده کنیم نیازی به لاک برای آرایه نخواهد بود.

منطق طراحی
-----------------

>>‫ یک سناریو را توضیح دهید که از بافر کش، `read-ahead` و یا از `write-behind` استفاده کند.

مثلا زمانی که داده ها در یک سرور قرار دارند بهتر است حداقل درخواست به آن را داشته باشیم زیرا مدت زمان زیادی برای هر درخواست صرف خواهد شد.
بنابراین بهتر است از 
`write-back`
استفاده کنیم.
ولی همانطور که در داک گفته شده روش 
`write-behind`
به این صورت است که به صورت متناوب این عملیات را انجام میدهد تا در صورت قطعی برق سکتورهای تغییر یافته از دست نروند.

همچنین فرض کنید داریم داده های بخشی از یک فایل بزرگ را لود میکنیم که  در چند  بلاک حافظه ذخیره شده است و احتمالا به بقیه آن فایل نیز نیاز شود پس بهتر از کل بلاک را نگهداریم تا درصورت نیاز سریعا به داده مورد نظر دسترسی داشته باشیم.

فایل‌های قابل گسترش
=====================

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```C
// filesys/inode.c

struct inode_disk
  {
    /* `start` is removed as file blocks are saved in the added variables now. */ 
    off_t length;                       /* Kept from design. */
    unsigned magic;                     /* Magic number. */

    bool is_dir;                        /* Refer to task 3. */

    block_sector_t direct[123];         /* Direct blocks of inode. */
    block_sector_t indirect;            /* Indirect blocks of inode. */
    block_sector_t double_indirect;     /* Double indirect blocks of indoe. */
    /* `unused` is removed as it's being used. :D */
  };

struct inode
  {
    ...
    struct lock f_lock;                 /* Synchronization between users of inode. */
  };

/* This signature has to change to comply with new file system. */
bool inode_create (/*block_sector_t sector*/ struct inode_disk * inode, off_t length);
```

توجه کنید که struct file آدرس inode را نگاه می‌دارد و به این ترتیب نیاز به تغییر ساختار برای پیاده‌سازی `inumber` وجود ندارد و تنها نیاز به پیاده‌سازی جزییات است.

>>‫ بیشترین سایز فایل پشتیبانی شده توسط ساختار inode شما چقدر است؟

$512 * (123 + 128 + 128 * 128) = 8_517_120$

<div dir="rtl">
توجه کنید که این مقدار از
$2^23 = 8_388_608$
که حداقل مقدار لازم است بزرگتر است.
</div>

همگام سازی
----------

>>‫ توضیح دهید که اگر دو پردازه بخواهند یک فایل را به طور همزمان گسترش دهند، کد شما چگونه از‫ حالت مسابقه جلوگیری می‌کند.

<div dir="rtl">
قفل `f_lock` داخل ساختار `inode` به همین منظور تعبیه شده است. هر پردازه‌ی که قصد گسترش پرونده را داشته باشد، ابتدای امر این قفل را در اختیار می‌گیرد. بدین ترتیب حداکثر یک پردازه به طور همزمان می‌تواند پرونده را گسترش دهد پس از حالت مسابقه در تاثیرگذاری آن‌ها جلوگیری می‌شود.
</div>

>>‫ فرض کنید دو پردازه‌ی A و B فایل F را باز کرده‌اند و هر دو به end-of-file اشاره کرده‌اند.‫ اگر  همزمان A از F بخواند و B روی آن بنویسد، ممکن است که A تمام، بخشی یا هیچ چیز از‫ اطلاعات نوشته شده توسط B را بخواند. همچنین A نمی‌تواند چیزی جز اطلاعات نوشته شده توسط B را‫ بخواند. مثلا اگر B تماما ۱ بنویسد، A نیز باید تماما ۱ بخواند. توضیح دهید کد شما چگونه از‫ این حالت مسابقه جلوگیری می‌کند.

<div dir="rtl">
از آن‌جایی که از قفل یکسانی برای خواندن و نوشتن روی یک پرونده استفاده شده است، تنها یکی از این پرونده‌ها این قفل را در اختیار می‌گیرد. پس از انجام عملیات موردنظر (خواندن، که با صفر بایت خواندن به اتمام می‌رسد و یا نوشتن که با نوشتن داده‌های موردنیاز پردازه و انتقال انتهای فایل به اتمام می‌رسد) پردازه‌ی دیگر می‌تواند قفل را در اختیار بگیرد و این بار پردازه با یک پرونده‌ی سازگار و به‌درستی‌تغییر‌داده‌شده مواجه است و می‌تواند بدون مشکل از آن بخواند و یا روی آن بنویسد.
</div>

>>‫ توضیح دهید همگام سازی شما چگونه "عدالت" را برقرار می‌کند. فایل سیستمی "عادل" است که‫ خواننده‌های اطلاعات به صورت ناسازگار نویسنده‌های اطلاعات را مسدود نکنند و برعکس. بدین ترتیب‫ اگر تعدادی بسیار زیاد پردازه‌هایی که از یک فایل می‌خوانند نمی‌توانند تا ابد مانع نوشده شدن‫ اطلاعات توسط یک پردازه‌ی دیگر شوند و برعکس.

<div dir="rtl">
توجه کنید که قفل یک پرونده هیچگاه مستقیما در اختیار پردازه قرار نمی‌گیرد و همواره در اختیار هسته است. به این ترتیب با چک کردن ورودی‌های توابع هسته، می‌توانیم مطمئن شویم که خواندن/نوشتن به طور نامحدود ادامه پیدا نمی‌کند. در نهایت پس از انجام **یک** عملیات خواندن و یا نوشتن، این قفل آزاد می‌شود و پردازه‌های دیگر می‌توانند آن را در اختیار بگیرد. با فرض این که زمان‌بند از starvation جلوگیری می‌کند، راهکار ارائه‌شده هم با مشکل starvation برخورد نمی‌کند. 
</div>

منطق طراحی
----------

>>‫ آیا ساختار `inode` شما از طبقه‌بندی چند سطحه پشتیبانی می‌کند؟ اگر بله، دلیل خود را برای‫ انتخاب این ترکیب خاص از بلوک‌های مستقیم، غیر مستقیم و غیر مستقیم دوطرفه توضیح دهید.‌‫ اگر خیر، دلیل خود برای انتخاب ساختاری غیر از طبقه‌بندی چند سطحه و مزایا و معایب ساختار‫ مورد استفاده خود نسبت به طبقه‌بندی چند سطحه را توضیح دهید.


<div dir="rtl">
مطابق توصیه‌ی داک از ساختار مشابه UNIX FFS برای ساختار inode استفاده شد که از طبقه‌بندی چند‌سطحه پشتیبانی می‌کند. از یک بلوک غیرمستقیم و یک بلوک غیرمسقیم دوطبقه برای inodeها استفاده شد. هدف از این بخش‌بندی افزایش سرعت دسترسی مستقیم در فایل‌های کوچک بود. (توجه کنید که این بخش‌بندی بیشترین تعداد بلوک مستقیم را در میان ساختارهایی که از حداقل اندازه‌ی ۸ مگابایت پشتیبانی می‌کنند داراست.) همچنین نیاز به استفاده از بلوک‌های دومرحله‌ای به هر حال وجود دارد (بدون آن‌ها حداکثر
$512 * 128 * 128 = 2^23$
را می‌توان در پرونده‌ها جا داد که به عدم امکان اختصاص کل ساختار به بلوک‌ها و همچنین افزایش زمان دسترسی مناسب نیست.)
علاوه بر این استفاده از یک بلوک غیرمستقیم به پرونده‌هایی با اندازه‌ی متوسط کمک می‌کند تا زمان دسترسی بهتری داشته باشند.
</div>

زیرمسیرها
============

داده‌ساختار‌ها و توابع
---------------------


>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.


```C
struct thread
{
    struct dir cwd;
}

struct dir
{
    struct lock dir_lock;
}

struct inode_disk
{
  ...
    bool is_dir;
  ...
}

struct inode
{
    bool deleted;
    int open_threads;
}

```

الگوریتم‌ها
-----------

>>‫ کد خود را برای طی کردن یک مسیر گرفته‌شده از کاربر را توضیح دهید.‫ آیا عبور از مسیرهای absolute و relative تفاوتی دارد؟

برای این کار اگر مسیر مطلق داشته باشیم از ریشه شروع میکنیم و به وسیله متد 
`get_next_part`
 که در داک اصلی کد آن آورده شده است نام بخش بعدی به دست می آوریم و تو در تو جلو می رویم.
 اگر آدرس نسبی باشد به وسیله 
 `cwd`
 که در هر ترد تعریف کردیم و آدرس نسبی به آدرس مطلق می رسیم. 

همگام سازی
-------------

>>‫ چگونه از رخ دادن race-condition در مورد دایرکتوری ها پیشگیری می‌کنید؟‫ برای مثال اگر دو درخواست موازی برای حذف یک فایل وجود داشته باشد و ‫ تنها یکی از آنها باید موفق شود یا مثلاً دو ریسه موازی بخواهند فایلی‫ یک اسم در یک مسیر ایجاد کنند و مانند آن.‫ آیا پیاده سازی شما اجازه می‌دهد مسیری که CWD یک ریسه شده یا پردازه‌ای‫ از آن استفاده می‌کند حذف شود؟ اگر بله، عملیات فایل سیستم بعدی روی آن‫ دایرکتوری چه نتیجه‌ای می‌دهند؟ اگر نه، چطور جلوی آن را می‌گیرید؟

برای سوال اول این کار را به وسیله ی 
`lock`
که برای هر
`inode`
در نظر گرفتیم مدیریت میکنیم.

اجازه پاک شدن میدهیم به این صورت که ابتدا وقتی یک 
`dir`
قرار است پاک شود به آن برچسب حذف شده میزنیم و برای هر 
`dir`
تعداد پردازه هایی که 
`cwd`
آنها همان 
`dir`
است را نگه میداریم و زمانی که این تعداد صفر بود و برچسب 
`deleted`
خورده بود آن را پاک میکنیم.

منطق طراحی
-----------------

>>‫ توضیح دهید چرا تصمیم گرفتید CWD یک پردازه را به شکلی که طراحی کرده‌اید‫ پیاده‌سازی کنید؟

به وسیله
`struct dir`
نگه داری میکنیم زیرا به نام وابسته نیستیم و با تغیر نام 
`working directory`
نیازی به هیچ تغیری نیست و زمان آدرس نسبی نیز به وسیله 
`lookup_dir`
به بخش بعدی میرویم.



افزون بر طراحی
============

`write_behind`: 

برای پیاده سازی این روش میتوانیم در ابتدای اجرای کرنل یک ترد بسازیم که هر بار پس از گذشت مدتی معین با حرکت بر روی بافرکش سکتورهایی که
`dirty=1`
هستند را در حافظه بنویسد.
(`write_back`)
به جای پیاده سازی ترد میتوان در 
`interrupt`
نیز این بررسی را انجام داد.

`read_ahead`:

برای پیاده سازی این روش باید با خواندن هر سکتور سکتور بعدی فایل را نیز در بافرکش .
این کار باعث میشود در هنگام خواندن به صورت متوالی 
`hit_rate`
افزایش یابد.
اما نکته این است که عملیات آوردن سکتور بعدی نباید کاربر را متوقف کند.
بنابراین بعد از آوردن سکتور مورد نظر یک ترد ایجاد کرده که در حین کارهای دیگر سکتور بعدی را وارد کش کند.




### سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد.

نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست.

ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>>‫ به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>>‫ آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>>‫ آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>>‫ آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>>‫ آیا حرف دیگری دارید؟